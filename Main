-- Enhanced Auto Farm System V2.0
-- Modular, Optimized, Feature-Rich

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

-- Services & Remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local BuyItemRemote = Remotes:WaitForChild("BuyItem")
local BuyGearRemote = Remotes:WaitForChild("BuyGear")
local AttacksRemote = Remotes:WaitForChild("AttacksServer"):WaitForChild("WeaponAttack")
local EquipBestBrainrotsRemote = Remotes:WaitForChild("EquipBestBrainrots")

-- Assets
local SeedsFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Seeds")
local GearsFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Gears")
local BatsFolder = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Bats")
local Brainrots = workspace:WaitForChild("ScriptedMap"):WaitForChild("Brainrots")

-- Player
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")
local function getBackpack()
    return LocalPlayer:FindFirstChild("Backpack")
end

-- Update character references on respawn
-----------------------
-----------------------
local Utils = {}

function Utils.SafeFireServer(remote, arg1, arg2)
	local success, err = pcall(function()
		if arg2 ~= nil then
			remote:FireServer(arg1, arg2)
		elseif arg1 ~= nil then
			remote:FireServer(arg1)
		else
			remote:FireServer()
		end
	end)
	if not success then
		warn("Remote call failed:", err)
	end
	return success
end

function Utils.GetVisibleSeeds()
	local list = {}
	for _, s in ipairs(SeedsFolder:GetChildren()) do
		if not s:GetAttribute("Hidden") then
			table.insert(list, s)
		end
	end
	return list
end

function Utils.GetShopGears()
	local list = {}
	for _, g in ipairs(GearsFolder:GetChildren()) do
		if g:GetAttribute("Price") ~= nil then
			table.insert(list, g)
		end
	end
	return list
end

function Utils.SortByPrice(items, descending)
	table.sort(items, function(a, b)
		local priceA = a:GetAttribute("Price") or 0
		local priceB = b:GetAttribute("Price") or 0
		if descending then
			return priceA > priceB
		else
			return priceA < priceB
		end
	end)
	return items
end

function Utils.GetTopItems(items, count)
	local sorted = Utils.SortByPrice(items, true)
	local result = {}
	for i = 1, math.min(count, #sorted) do
		table.insert(result, sorted[i])
	end
	return result
end

function Utils.FormatCurrency(amount)
	if amount >= 1e9 then
		return string.format("%.2fB", amount / 1e9)
	elseif amount >= 1e6 then
		return string.format("%.2fM", amount / 1e6)
	elseif amount >= 1e3 then
		return string.format("%.2fK", amount / 1e3)
	else
		return tostring(amount)
	end
end

-----------------------
-- SEED PREDICTION DATA
-----------------------
local SeedChances = {
	["Dragon Fruit Seed"] = {33, 5, 2},
	["Eggplant Seed"] = {10},
	["Watermelon Seed"] = {5},
	["Grape Seed"] = {3.5},
	["Cocotank Seed"] = {2},
	["Carnivorous Plant Seed"] = {1.5},
	["Pine-a-Punch Seed"] = {1.25},
	["Mr Carrot Seed"] = {1},
	["Tomatrio Seed"] = {0.75},
	["Shroombino Seed"] = {0.5},
	["Mango Seed"] = {0.267},
}

local function GetSeedProbability(seedName)
	local chances = SeedChances[seedName]
	if chances and #chances > 0 then
		local sum = 0
		for _, v in ipairs(chances) do sum = sum + v end
		return sum / #chances / 100
	end
	return 1
end

-- AUTO BUYER MODULE
-----------------------
local AutoBuyer = {}
AutoBuyer.__index = AutoBuyer

function AutoBuyer.new(itemType, folder, buyRemote, buyDelay)
	local self = setmetatable({}, AutoBuyer)
	self.itemType = itemType
	self.folder = folder
	self.buyRemote = buyRemote
	self.buyDelay = buyDelay or 0.08
	self.running = false
	self.modes = {
		selected = false,
		all = false,
		best = false
	}
	self.selectedItems = {}
	self.topCount = 3
	self.purchaseCount = 0
	self.totalSpent = 0
	return self
end

function AutoBuyer:GetItems()
    if self.itemType == "seed" then
        return Utils.GetVisibleSeeds()
    else
        return Utils.GetShopGears()
    end
end

function AutoBuyer:DeterminePurchaseList()
    local items = {}
    
    if self.modes.all then
        items = self:GetItems()
    elseif self.modes.best then
        items = Utils.GetTopItems(self:GetItems(), self.topCount)
    elseif self.modes.selected then
        for _, name in ipairs(self.selectedItems) do
            local inst = self.folder:FindFirstChild(name)
            if inst then
                if self.itemType == "seed" and not inst:GetAttribute("Hidden") then
                    table.insert(items, inst)
                elseif self.itemType == "gear" and inst:GetAttribute("Price") ~= nil then
                    table.insert(items, inst)
                end
            end
        end
    end
    return items
end

function AutoBuyer:BuyItem(item)
    local stock = item:GetAttribute("Stock") or 0
    local price = item:GetAttribute("Price") or 0
    
    local actualPurchases = 0

    if stock > 0 then
        local attempts = stock
        -- Baselines for aggregate fallback confirmation
        local moneyBaseline = (Statistics and Statistics.GetCurrentMoney and Statistics:GetCurrentMoney()) or nil
        local spentBaseline = (Statistics and Statistics.spent) or 0
        local stockBaseline = tonumber(item:GetAttribute("Stock")) or stock
        for i = 1, attempts do
            -- Snapshot before
            local moneyBefore = (Statistics and Statistics.GetCurrentMoney and Statistics:GetCurrentMoney()) or nil
            local spentBefore = (Statistics and Statistics.spent) or 0
            local stockBefore = tonumber(item:GetAttribute("Stock")) or 0

            -- Fire once
            local firedOk = Utils.SafeFireServer(self.buyRemote, item.Name, true)
            if not firedOk then break end

            -- Poll up to 6s for any confirmation: money down OR spent up OR stock down
            local confirmed = false
            local waited = 0
            local maxWait = 6.0
            local step = math.max(0.05, self.buyDelay)
            while waited < maxWait do
                task.wait(step)
                waited = waited + step
                local moneyNow = (Statistics and Statistics.GetCurrentMoney and Statistics:GetCurrentMoney()) or moneyBefore
                local spentNow = (Statistics and Statistics.spent) or spentBefore
                local stockNow = tonumber(item:GetAttribute("Stock")) or stockBefore

                local moneyDelta = (moneyBefore and moneyNow) and (moneyBefore - moneyNow) or 0
                local spentDelta = (spentNow - spentBefore)
                local stockDelta = stockBefore - stockNow

                if (moneyDelta and moneyDelta > 0) or (spentDelta and spentDelta > 0) or (stockDelta and stockDelta > 0) then
                    confirmed = true
                    break
                end
            end

            if confirmed then
                actualPurchases = actualPurchases + 1
            else
                -- Not confirmed yet; continue attempts and rely on aggregate fallback below
            end
        end

        -- Final grace wait before aggregate reconciliation
        do
            local extraWait = 2.0
            local step = math.max(0.05, self.buyDelay)
            local waited = 0
            while waited < extraWait do
                task.wait(step)
                waited = waited + step
            end
        end

        -- Aggregate reconciliation: compute total confirmed from baselines
        local moneyAfter = (Statistics and Statistics.GetCurrentMoney and Statistics:GetCurrentMoney()) or moneyBaseline
        local spentAfter = (Statistics and Statistics.spent) or spentBaseline
        local stockAfter = tonumber(item:GetAttribute("Stock")) or stockBaseline
        local inferredByMoney = 0
        local inferredBySpent = 0
        local inferredByStock = 0
        local priceNum = tonumber(price) or 0
        if priceNum > 0 then
            if moneyBaseline and moneyAfter then
                local moneyDelta = (moneyBaseline - moneyAfter)
                if moneyDelta and moneyDelta > 0 then
                    inferredByMoney = math.floor((moneyDelta + 1e-6) / priceNum)
                end
            end
            if spentAfter and spentBaseline then
                local spentDelta = (spentAfter - spentBaseline)
                if spentDelta and spentDelta > 0 then
                    inferredBySpent = math.floor((spentDelta + 1e-6) / priceNum)
                end
            end
        else
            if stockBaseline and stockAfter and stockAfter <= stockBaseline then
                inferredByStock = math.max(0, stockBaseline - stockAfter)
            end
        end
        local addedByAggregate = math.max(inferredByMoney, inferredBySpent, inferredByStock)
        if addedByAggregate > actualPurchases then
            actualPurchases = addedByAggregate
        end
    end
    
    -- Only increment counters if we actually made purchases
    if actualPurchases > 0 then
        self.purchaseCount = self.purchaseCount + actualPurchases
        self.totalSpent = self.totalSpent + (price * actualPurchases)
        -- Do not record seed purchases here; backpack-based tracker will handle counts
    end
    
    return actualPurchases
end

function AutoBuyer:Start()
	if self.running then return end
	self.running = true
	
	task.spawn(function()
		while self.modes.selected or self.modes.all or self.modes.best do
			local itemsToBuy = self:DeterminePurchaseList()
			-- Try each item; BuyItem has its own confirmation and will stop per item when out of stock
			for _, item in ipairs(itemsToBuy) do
				if not self.running then break end
				self:BuyItem(item)
			end
			task.wait(3)
		end
		self.running = false
	end)
end

function AutoBuyer:Stop()
	self.running = false
	for k, _ in pairs(self.modes) do
		self.modes[k] = false
	end
end

function AutoBuyer:GetStats()
	return {
		purchases = self.purchaseCount,
		spent = self.totalSpent
	}
end

-----------------------
-- AUTO COMBAT MODULE (Based on original working code)
-----------------------
local AutoCombat = {}
AutoCombat.__index = AutoCombat

function AutoCombat.new()
	local self = setmetatable({}, AutoCombat)
	self.enabled = false
	self.attackDelay = 0.1
	self.attackRange = 10
	self.running = false
	self.highlightEnabled = true
	self.currentOutline = nil
	self.currentTarget = nil
	self.lastTarget = nil
	self.originalColors = {}
	self.weaponSlot = 1
	self.equippedTool = nil
	self.currentToolName = "None"
	return self
end

function AutoCombat:GetNearestEnemy()
	local nearest = nil
	local nearestDist = math.huge
	
	for _, enemy in ipairs(Brainrots:GetChildren()) do
		local enemyHRP = enemy:FindFirstChild("HumanoidRootPart") or enemy.PrimaryPart
		if enemyHRP then
			local dist = (HumanoidRootPart.Position - enemyHRP.Position).Magnitude
			if dist < nearestDist then
				nearestDist = dist
				nearest = enemy
			end
		end
	end
	
	return nearest
end

function AutoCombat:HighlightEnemy(enemy)
	-- Remove old highlight
	self:RemoveHighlight()
	
	if self.highlightEnabled and enemy and enemy:IsDescendantOf(workspace) then
		-- Store original colors
		for _, part in ipairs(enemy:GetDescendants()) do
			if part:IsA("BasePart") then
				self.originalColors[part] = {
					Color = part.Color,
					Transparency = part.Transparency
				}
				-- Set to transparent red
				part.Color = Color3.fromRGB(255, 0, 0)
				part.Transparency = 0.5
			end
		end
	end
end

function AutoCombat:RemoveHighlight()
	-- Restore original colors
	for part, original in pairs(self.originalColors) do
		if part and part.Parent then
			part.Color = original.Color
			part.Transparency = original.Transparency
		end
	end
	self.originalColors = {}
end

-- (Removed) ResolveHealthAttribute no longer used

function AutoCombat:GetOwnedCombatTool()
	-- Build a set of valid tool names from ReplicatedStorage.Assets.Bats
	local validNames = {}
	for _, tool in ipairs(BatsFolder:GetChildren()) do
		validNames[tool.Name] = true
	end

	-- Check character (already equipped)
	for _, t in ipairs(Character:GetChildren()) do
		if t:IsA("Tool") and validNames[t.Name] then
			return t
		end
	end

	-- Then check backpack
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		for _, t in ipairs(backpack:GetChildren()) do
			if t:IsA("Tool") and validNames[t.Name] then
				return t
			end
		end
	end

	return nil
end

function AutoCombat:AutoEquipTool()
	local tool = self:GetOwnedCombatTool()
	if tool then
		self.currentToolName = tool.Name
		self.equippedTool = tool
		pcall(function()
			if Humanoid and Humanoid.Parent then
				Humanoid:EquipTool(tool)
			else
				tool.Parent = Character
			end
		end)
		return true
	end
	self.currentToolName = "None"
	self.equippedTool = nil
	return false
end

function AutoCombat:MoveToTarget(target)
	local targetHRP = target:FindFirstChild("HumanoidRootPart") or target.PrimaryPart
	if not targetHRP then return end

	task.spawn(function()
		while self.enabled and target.Parent do
			Humanoid:MoveTo(targetHRP.Position)
			task.wait(0.1)
		end
	end)
end

function AutoCombat:Start()
	if self.running then return end
	self.running = true
	self.enabled = true

	-- Equip immediately
	self:AutoEquipTool()

	task.spawn(function()
		local lastEnemy = nil
		while self.enabled do
			-- Ensure tool stays equipped
			if not self.equippedTool or self.equippedTool.Parent ~= Character then
				self:AutoEquipTool()
			end

			local enemy = self:GetNearestEnemy()

			-- Update current target for stats display
			self.currentTarget = enemy

			if enemy ~= lastEnemy then
				lastEnemy = enemy
				self:HighlightEnemy(enemy)
			end
			if enemy then
				self:MoveToTarget(enemy)

				if enemyHRP then
					while enemy.Parent and self.enabled and enemyHRP.Parent do
						local distance = (HumanoidRootPart.Position - enemyHRP.Position).Magnitude
						if distance > self.attackRange then break end

						pcall(function()
							AttacksRemote:FireServer({enemy.Name})
						end)
						task.wait(self.attackDelay)
					end
				end
			else
				-- No enemy found, remove highlight

-- Seed Tracking Controls
local SeedTrackingSection = SettingsTab:CreateSection("Seed Tracking")

local ResetBaselineButton = SettingsTab:CreateButton({
    Name = "Reset Seed Baseline",
    Callback = function()
        Statistics:ResetSeedBaseline()
        Rayfield:Notify({
            Title = "Baseline Reset",
            Content = "Seed baseline reset. Purchases cleared.",
            Duration = 3,
            Image = 4483362458,
        })
    end,
})
				self:RemoveHighlight()
				lastEnemy = nil
			end

			-- Ensure highlight respects toggle even while moving
			if self.highlightEnabled and lastEnemy then
				self:HighlightEnemy(lastEnemy)
			else
				self:RemoveHighlight()
			end

			task.wait(0.1)
		end

		self.running = false
		self.currentTarget = nil
		self:RemoveHighlight()
	end)
end

function AutoCombat:Stop()
	self.enabled = false
	self:RemoveHighlight()
end

function AutoCombat:GetStats()
	return {
		target = self.currentTarget
	}
end
--- STATISTICS TRACKER
-----------------------
Statistics = {
    sessionStart = tick(),
    startingMoney = nil,
    lastMoney = nil,
    spent = 0,
    gained = 0,
    seedPurchases = {},
    seedBaseline = {},
    seedLastSeen = {},
}

function Statistics:InitMoneyTracker()
    local leaderstats = LocalPlayer:FindFirstChild("leaderstats") or LocalPlayer:WaitForChild("leaderstats")
    local moneyVal = leaderstats and (leaderstats:FindFirstChild("Money") or leaderstats:WaitForChild("Money"))
    if moneyVal and moneyVal.Value ~= nil then
        self.startingMoney = tonumber(moneyVal.Value) or 0
        self.lastMoney = self.startingMoney
    else
        self.startingMoney = 0
        self.lastMoney = 0
    end
end

function Statistics:GetCurrentMoney()
    local leaderstats = LocalPlayer:FindFirstChild("leaderstats")
    local moneyVal = leaderstats and leaderstats:FindFirstChild("Money")
    if moneyVal and moneyVal.Value ~= nil then
        return tonumber(moneyVal.Value) or 0
    end
    return 0
end

-- Backpack-based seed purchase tracker using ItemName + Uses
function Statistics:_buildVisibleSeedSet()
    local valid = {}
    for _, seed in ipairs(SeedsFolder:GetChildren()) do
        if not seed:GetAttribute("Hidden") then
            valid[seed.Name] = true
        end
    end
    return valid
end

function Statistics:_readBackpackSeedCounts()
    local counts = {}
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then return counts end
    local valid = self:_buildVisibleSeedSet()
    for _, inst in ipairs(backpack:GetChildren()) do
        local itemName = inst:GetAttribute("ItemName")
        local uses = inst:GetAttribute("Uses")
        if itemName and uses ~= nil and valid[itemName] then
            counts[itemName] = (counts[itemName] or 0) + (tonumber(uses) or 0)
        end
    end
    return counts
end

function Statistics:InitSeedBaseline()
    self.seedBaseline = {}
    self.seedLastSeen = {}
    local now = self:_readBackpackSeedCounts()
    for name, cnt in pairs(now) do
        self.seedBaseline[name] = cnt
        self.seedLastSeen[name] = cnt
    end
end

function Statistics:UpdateSeedPurchasesFromBackpack()
    if not next(self.seedBaseline) then
        self:InitSeedBaseline()
    end
    local current = self:_readBackpackSeedCounts()
    for name, curr in pairs(current) do
        local last = self.seedLastSeen[name] or curr
        if curr > last then
            local delta = curr - last
            self.seedPurchases[name] = (self.seedPurchases[name] or 0) + delta
        end
        self.seedLastSeen[name] = curr
    end
end

function Statistics:ResetSeedBaseline()
    -- Clear session purchases and rebuild baseline from current backpack
    self.seedPurchases = {}
    self:InitSeedBaseline()
end

function Statistics:RecordSeedPurchase(name, count)
    if not name or name == "" then return end
    count = tonumber(count) or 1
    self.seedPurchases[name] = (self.seedPurchases[name] or 0) + count
end

function Statistics:GetSeedPurchasesSummary(limit)
    limit = limit or 10
    local entries = {}
    for k, v in pairs(self.seedPurchases) do
        table.insert(entries, {name = k, count = v})
    end
    table.sort(entries, function(a,b) return a.count > b.count end)
    if #entries == 0 then return "Seeds Bought: None" end
    local lines = {"Seeds Bought (top "..math.min(limit, #entries).."):"}
    for i = 1, math.min(limit, #entries) do
        local e = entries[i]
        table.insert(lines, string.format("- %s: %d", e.name, e.count))
    end
    return table.concat(lines, "\n")
end

function Statistics:UpdateMoney()
    if self.startingMoney == nil then
        self:InitMoneyTracker()
        return
    end
    local current = self:GetCurrentMoney()
    if self.lastMoney ~= nil then
        local delta = current - self.lastMoney
        if delta > 0 then
            self.gained = self.gained + delta
        elseif delta < 0 then
            self.spent = self.spent + (-delta)
        end
    end
    self.lastMoney = current
end

function Statistics:GetUptime()
    local uptime = tick() - self.sessionStart
    local hours = math.floor(uptime / 3600)
    local minutes = math.floor((uptime % 3600) / 60)
    local seconds = math.floor(uptime % 60)
    return string.format("%02dh %02dm %02ds", hours, minutes, seconds)
end

function Statistics:GenerateReport()
    local currentMoney = self:GetCurrentMoney()
    local base = string.format(
        "Session Stats:\n" ..
        "Uptime: %s\n" ..
        "Current Money: %s\n" ..
        "Money Spent: %s\n" ..
        "Money Gained: %s\n",
        self:GetUptime(),
        Utils.FormatCurrency(currentMoney),
        Utils.FormatCurrency(self.spent or 0),
        Utils.FormatCurrency(self.gained or 0)
    )
    local seeds = self:GetSeedPurchasesSummary(10)
    return base .. seeds
end

-----------------------
-- RAYFIELD UI SETUP
-----------------------
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
	Name = "Enhanced Auto Farm V2.0",
	LoadingTitle = "Elite Farming System",
	LoadingSubtitle = "by Nisul | Optimized & Enhanced",
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "EnhancedAutoFarm",
		FileName = "AutoFarmConfig_V2"
	}
})

-----------------------
-- DASHBOARD TAB
-----------------------
local DashboardTab = Window:CreateTab("Dashboard", 4483362458)
local StatsSection = DashboardTab:CreateSection("Session Statistics")

local StatsParagraph = DashboardTab:CreateParagraph({
	Title = "Statistics",
	Content = "Initializing..."
})

-- Update stats every 1 second
task.spawn(function()
	while true do
		-- Track money deltas each tick
		Statistics:UpdateMoney()
		-- Update seed purchases based on Backpack ItemName/Uses deltas
		Statistics:UpdateSeedPurchasesFromBackpack()
		StatsParagraph:Set({
			Title = "Session Statistics",
			Content = Statistics:GenerateReport()
		})
		task.wait(1)
	end
end)

-----------------------
-- SEED BUYER TAB
-----------------------
-----------------------
-- BACKPACK TAB
-----------------------
local BackpackTab = Window:CreateTab("Backpack", 4483362458)
local BackpackSection = BackpackTab:CreateSection("Player Seeds (Backpack)")

local BackpackParagraph = BackpackTab:CreateParagraph({
    Title = "Backpack Seeds",
    Content = "Scanning..."
})

local function BuildBackpackSeedSummary()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then
        return "Backpack not found"
    end

    -- Build allowlist of visible seeds from ReplicatedStorage.Assets.Seeds
    local valid = {}
    for _, seed in ipairs(SeedsFolder:GetChildren()) do
        if not seed:GetAttribute("Hidden") then
            valid[seed.Name] = true
        end
    end

    -- Sum Uses by ItemName attribute (backpack tools may be named like "[x2] Carrot Seed")
    local counts = {}
    for _, inst in ipairs(backpack:GetChildren()) do
        -- Match using ItemName attribute instead of Instance.Name
        local itemName = inst:GetAttribute("ItemName")
        local uses = inst:GetAttribute("Uses")
        if itemName and uses ~= nil and valid[itemName] then
            counts[itemName] = (counts[itemName] or 0) + (tonumber(uses) or 0)
        end
    end

    -- Format output
    local lines = {}
    for name, count in pairs(counts) do
        table.insert(lines, string.format("- %s: %d", name, count))
    end
    table.sort(lines) -- alphabetical
    if #lines == 0 then
        return "No visible seeds found in Backpack (with Uses attribute)."
    end
    return table.concat(lines, "\n")
end

task.spawn(function()
    while true do
        local summary = BuildBackpackSeedSummary()
        BackpackParagraph:Set({
            Title = "Backpack Seeds",
            Content = summary
        })
        task.wait(2)
    end
end)

-----------------------
-- SEED BUYER TAB
-----------------------
local SeedTab = Window:CreateTab("Seed Buyer", 4483362458)
local SeedSection = SeedTab:CreateSection("Auto Seed Purchasing")

local seedBuyer = AutoBuyer.new("seed", SeedsFolder, BuyItemRemote, 0.08)

local seedNamesList = {}
for _, s in ipairs(Utils.GetVisibleSeeds()) do
	table.insert(seedNamesList, s.Name)
end

local SeedDropdown = SeedTab:CreateDropdown({
	Name = "Select Seeds to Buy",
	Options = seedNamesList,
	MultipleOptions = true,
	CurrentOption = {},
	Flag = "SeedDropdown",
	Callback = function(selected)
		seedBuyer.selectedItems = selected or {}
	end,
})

local SeedTopSlider = SeedTab:CreateSlider({
	Name = "Top X Seeds (by Price)",
	Range = {1, 15},
	Increment = 1,
	CurrentValue = 3,
	Flag = "TopSeedCount",
	Callback = function(value)
		seedBuyer.topCount = value
	end,
})

local BestSeedsParagraph = SeedTab:CreateParagraph({
	Title = "Best Seeds Preview",
	Content = "Select 'Auto Buy Best Seeds' to see preview"
})

local SeedToggleSelected = SeedTab:CreateToggle({
	Name = "Auto Buy Selected Seeds",
	CurrentValue = false,
	Flag = "AutoBuySelectedSeeds",
	Callback = function(value)
		seedBuyer.modes.selected = value
		if value then seedBuyer:Start() end
	end,
})

local SeedToggleAll = SeedTab:CreateToggle({
	Name = "Auto Buy All Seeds",
	CurrentValue = false,
	Flag = "AutoBuyAllSeeds",
	Callback = function(value)
		seedBuyer.modes.all = value
		if value then seedBuyer:Start() end
	end,
})

local SeedToggleBest = SeedTab:CreateToggle({
	Name = "Auto Buy Best Seeds",
	CurrentValue = false,
	Flag = "AutoBuyBestSeeds",
	Callback = function(value)
		seedBuyer.modes.best = value
		if value then
			seedBuyer:Start()
			-- Update preview
			task.spawn(function()
				while seedBuyer.modes.best do
					local best = Utils.GetTopItems(Utils.GetVisibleSeeds(), seedBuyer.topCount)
					if #best > 0 then
						local txt = string.format("Top %d Seeds:\n\n", seedBuyer.topCount)
						for i, inst in ipairs(best) do
							txt = txt .. string.format(
								"%d. %s\n   Price: %s | Stock: %d\n",
								i,
								inst.Name,
								Utils.FormatCurrency(inst:GetAttribute("Price") or 0),
								inst:GetAttribute("Stock") or 0
							)
						end
						BestSeedsParagraph:Set({Title = "Best Seeds Preview", Content = txt})
					end
					task.wait(5)
				end
			end)
		end
	end,
})

-- Seed Predictions
local SeedPredSection = SeedTab:CreateSection("Stock Predictions")

local PredictionsParagraph = SeedTab:CreateParagraph({
	Title = "Predicted Stock (Next Refresh)",
	Content = "Calculating..."
})

local function UpdateSeedPredictions()
	local predictions = {}
	for _, s in ipairs(Utils.GetVisibleSeeds()) do
		local prob = GetSeedProbability(s.Name)
		local maxStock = s:GetAttribute("Stock") or 1
		local expected = math.floor(prob * maxStock + 0.5)
		table.insert(predictions, {
			name = s.Name,
			expected = expected,
			probability = prob * 100
		})
	end
	
	table.sort(predictions, function(a, b) return a.expected > b.expected end)
	
	local txt = ""
	for i, pred in ipairs(predictions) do
		txt = txt .. string.format(
			"%d. %s\n   Expected: %d units (%.1f%% chance)\n",
			i,
			pred.name,
			pred.expected,
			pred.probability
		)
	end
	
	PredictionsParagraph:Set({
		Title = "Predicted Stock (Next Refresh)",
		Content = txt
	})
end

task.spawn(function()
	while true do
		UpdateSeedPredictions()
		task.wait(300)
	end
end)
UpdateSeedPredictions()

-----------------------
-- GEAR BUYER TAB
-----------------------
local GearTab = Window:CreateTab("Gear Buyer", 4483362458)
local GearSection = GearTab:CreateSection("Auto Gear Purchasing")

local gearBuyer = AutoBuyer.new("gear", GearsFolder, BuyGearRemote, 0.12)

local gearNamesList = {}
for _, g in ipairs(Utils.GetShopGears()) do
	table.insert(gearNamesList, g.Name)
end

local GearDropdown = GearTab:CreateDropdown({
	Name = "Select Gears to Buy",
	Options = gearNamesList,
	MultipleOptions = true,
	CurrentOption = {},
	Flag = "GearDropdown",
	Callback = function(opts)
		gearBuyer.selectedItems = opts or {}
	end,
})

local GearTopSlider = GearTab:CreateSlider({
	Name = "Top X Gears (by Price)",
	Range = {1, 15},
	Increment = 1,
	CurrentValue = 3,
	Flag = "TopGearCount",
	Callback = function(value)
		gearBuyer.topCount = value
	end,
})

local BestGearsParagraph = GearTab:CreateParagraph({
	Title = "Best Gears Preview",
	Content = "Select 'Auto Buy Best Gears' to see preview"
})

local GearToggleSelected = GearTab:CreateToggle({
	Name = "Auto Buy Selected Gears",
	CurrentValue = false,
	Flag = "AutoBuySelectedGears",
	Callback = function(value)
		gearBuyer.modes.selected = value
		if value then gearBuyer:Start() end
	end,
})

local GearToggleAll = GearTab:CreateToggle({
	Name = "Auto Buy All Gears",
	CurrentValue = false,
	Flag = "AutoBuyAllGears",
	Callback = function(value)
		gearBuyer.modes.all = value
		if value then gearBuyer:Start() end
	end,
})

local GearToggleBest = GearTab:CreateToggle({
	Name = "Auto Buy Best Gears",
	CurrentValue = false,
	Flag = "AutoBuyBestGears",
	Callback = function(value)
		gearBuyer.modes.best = value
		if value then
			gearBuyer:Start()
			-- Update preview
			task.spawn(function()
				while gearBuyer.modes.best do
					local best = Utils.GetTopItems(Utils.GetShopGears(), gearBuyer.topCount)
					if #best > 0 then
						local txt = string.format("Top %d Gears:\n\n", gearBuyer.topCount)
						for i, inst in ipairs(best) do
							txt = txt .. string.format(
								"%d. %s\n   Price: %s | Stock: %d\n",
								i,
								inst.Name,
								Utils.FormatCurrency(inst:GetAttribute("Price") or 0),
								inst:GetAttribute("Stock") or 0
							)
						end
						BestGearsParagraph:Set({Title = "Best Gears Preview", Content = txt})
					end
					task.wait(5)
				end
			end)
		end
	end,
})

-----------------------
-- COMBAT TAB
-----------------------
local CombatTab = Window:CreateTab("Auto Combat", 4483362458)
local CombatSection = CombatTab:CreateSection("Enemy Auto Attack")

local combat = AutoCombat.new()

local CombatToggle = CombatTab:CreateToggle({
	Name = "Auto Attack Enemies",
	CurrentValue = false,
	Flag = "AutoAttackEnabled",
	Callback = function(value)
		if value then
			combat:Start()
		else
			combat:Stop()
		end
	end,
})

local AttackDelaySlider = CombatTab:CreateSlider({
	Name = "Attack Delay (seconds)",
	Range = {0.05, 1},
	Increment = 0.01,
	CurrentValue = 0.1,
	Flag = "AttackDelay",
	Callback = function(value)
		combat.attackDelay = value
	end,
})

local AttackRangeSlider = CombatTab:CreateSlider({
	Name = "Attack Range",
	Range = {5, 30},
	Increment = 1,
	CurrentValue = 10,
	Flag = "AttackRange",
	Callback = function(value)
		combat.attackRange = value
	end,
})

local HighlightToggle = CombatTab:CreateToggle({
	Name = "Highlight Target (Transparent Red)",
	CurrentValue = true,
	Flag = "HighlightTarget",
	Callback = function(value)
		combat.highlightEnabled = value
		if not value then
			combat:RemoveHighlight()
		end
	end,
})

local CombatStatsParagraph = CombatTab:CreateParagraph({
	Title = "Combat Statistics",
	Content = "No target"
})

task.spawn(function()
	while true do
		if combat.enabled then
			local targetName = "None"
			if combat.currentTarget and combat.currentTarget.Parent then
				local brainName = combat.currentTarget:GetAttribute("Brainrot")
				targetName = (brainName and tostring(brainName)) or combat.currentTarget.Name
			end
			CombatStatsParagraph:Set({
				Title = "Combat Statistics",
				Content = string.format("Tool: %s | Target: %s", combat.currentToolName or "None", targetName)
			})
		end
		task.wait(1)
	end
end)

-----------------------
-- AUTO TAB
-----------------------
local AutoTab = Window:CreateTab("Auto", 4483362458)
local AutoSection = AutoTab:CreateSection("Automatic Actions")

local autoEquip = {
    enabled = false,
    delay = 30,
    running = false,
}

local AutoEquipDelaySlider = AutoTab:CreateSlider({
    Name = "Equip Best Brainrots Delay (sec)",
    Range = {1, 300},
    Increment = 1,
    CurrentValue = 30,
    Flag = "EquipBestDelay",
    Callback = function(value)
        autoEquip.delay = value
    end,
})

local function StartAutoEquip()
    if autoEquip.running then return end
    autoEquip.running = true
    task.spawn(function()
        while autoEquip.enabled do
            -- Fire the remote to equip best brainrots
            Utils.SafeFireServer(EquipBestBrainrotsRemote)
            -- Wait for user-configured delay
            local d = tonumber(autoEquip.delay) or 30
            task.wait(math.max(0.1, d))
        end
        autoEquip.running = false
    end)
end

local AutoEquipToggle = AutoTab:CreateToggle({
    Name = "Auto Equip Best Brainrots",
    CurrentValue = false,
    Flag = "AutoEquipBestBrainrots",
    Callback = function(value)
        autoEquip.enabled = value
        if value then
            StartAutoEquip()
        end
    end,
})

-----------------------
-- SETTINGS TAB
-----------------------
local SettingsTab = Window:CreateTab("Settings", 4483362458)
local SettingsSection = SettingsTab:CreateSection("Configuration")

local SeedDelaySlider = SettingsTab:CreateSlider({
    Name = "Seed Buy Delay (seconds)",
    Range = {0.05, 0.5},
    Increment = 0.01,
    CurrentValue = 0.08,
    Flag = "SeedBuyDelay",
    Callback = function(value)
        seedBuyer.buyDelay = value
    end,
})

local GearDelaySlider = SettingsTab:CreateSlider({
	Name = "Gear Buy Delay (seconds)",
	Range = {0.05, 0.5},
	Increment = 0.01,
	CurrentValue = 0.12,
	Flag = "GearBuyDelay",
	Callback = function(value)
		gearBuyer.buyDelay = value
	end,
})

-- Seed Tracking Controls
local SeedTrackingSection = SettingsTab:CreateSection("Seed Tracking")

local ResetBaselineButton = SettingsTab:CreateButton({
    Name = "Reset Seed Baseline",
    Callback = function()
        Statistics:ResetSeedBaseline()
        Rayfield:Notify({
            Title = "Baseline Reset",
            Content = "Seed baseline reset. Purchases cleared.",
            Duration = 3,
            Image = 4483362458,
        })
    end,
})

local StopAllButton = SettingsTab:CreateButton({
    Name = "Emergency Stop All",
    Callback = function()
        seedBuyer:Stop()
        gearBuyer:Stop()
        combat:Stop()
        -- Visually turn off all toggles
        pcall(function()
            if SeedToggleBest then SeedToggleBest:Set(false) end
            if SeedToggleSelected then SeedToggleSelected:Set(false) end
            if SeedToggleAll then SeedToggleAll:Set(false) end
            if GearToggleBest then GearToggleBest:Set(false) end
            if GearToggleSelected then GearToggleSelected:Set(false) end
            if GearToggleAll then GearToggleAll:Set(false) end
            if CombatToggle then CombatToggle:Set(false) end
            if HighlightToggle then HighlightToggle:Set(false) end
            if AutoEquipToggle then AutoEquipToggle:Set(false) end
            if WebhookToggle then WebhookToggle:Set(false) end
        end)
        Rayfield:Notify({
            Title = "Emergency Stop",
            Content = "All auto-farm functions stopped",
            Duration = 3,
            Image = 4483362458,
        })
    end,
})

-- Discord Webhook Integration
local WebhookSection = SettingsTab:CreateSection("Discord Webhook")

local Webhook = {
    url = "",
    enabled = false,
    interval = 300,
    running = false,
}

-- Readable URL mirror (makes it easier to review long webhook URLs)
local WebhookUrlParagraph = SettingsTab:CreateParagraph({
    Title = "Current Webhook URL",
    Content = "(none)"
})

local WebhookUrlBox = SettingsTab:CreateInput({
    Name = "Webhook URL",
    PlaceholderText = "https://discord.com/api/webhooks/...",
    RemoveTextAfterFocusLost = false,
    Flag = "WebhookUrl",
    Callback = function(text)
        local raw = tostring(text or "")
        -- trim whitespace
        local trimmed = raw:match("^%s*(.-)%s*$") or raw
        Webhook.url = trimmed
        -- Update visible mirror for readability
        WebhookUrlParagraph:Set({
            Title = "Current Webhook URL",
            Content = (#trimmed > 0) and trimmed or "(none)"
        })
        -- Persist URL to disk (if executor supports it)
        local ok, err = pcall(function()
            local payload = HttpService:JSONEncode({ url = trimmed })
            if writefile then
                local folder = "EnhancedAutoFarm"
                if makefolder then pcall(function() makefolder(folder) end) end
                writefile(folder .. "/webhook_url.json", payload)
            end
        end)
        if not ok and err then warn("Failed to save webhook url:", err) end
    end,
})

local function LoadWebhookUrl()
    -- Load from disk first (explicit), then fall back to Rayfield-loaded value
    local loaded = nil
    pcall(function()
        if readfile then
            local path = "EnhancedAutoFarm/webhook_url.json"
            if isfile and isfile(path) then
                local data = readfile(path)
                local obj = HttpService:JSONDecode(data)
                loaded = type(obj)=="table" and obj.url or nil
            end
        end
    end)
    -- If explicit load found a value, use it; else try to read current input text via Flag reflection
    local url = loaded or Webhook.url or ""
    if type(url) ~= "string" then url = "" end
    Webhook.url = url
    -- Reflect in UI (if Rayfield element exposes Set)
    if WebhookUrlBox and WebhookUrlBox.Set then
        pcall(function() WebhookUrlBox:Set(url) end)
    end
    WebhookUrlParagraph:Set({
        Title = "Current Webhook URL",
        Content = (#url > 0) and url or "(none)"
    })
end

local WebhookIntervalSlider = SettingsTab:CreateSlider({
    Name = "Report Interval (sec)",
    Range = {30, 3600},
    Increment = 10,
    CurrentValue = 300,
    Flag = "WebhookInterval",
    Callback = function(value)
        Webhook.interval = value
    end,
})

local function BuildDiscordEmbed()
    local currentMoney = Statistics:GetCurrentMoney()
    local uptime = Statistics:GetUptime()
    local spent = Statistics.spent or 0
    local gained = Statistics.gained or 0
    local seedsSummary = Statistics:GetSeedPurchasesSummary(10)

    return {
        title = "Auto Farm Status",
        color = 0x33AAFF,
        fields = {
            { name = "Uptime", value = uptime, inline = true },
            { name = "Current Money", value = Utils.FormatCurrency(currentMoney), inline = true },
            { name = "Money Spent", value = Utils.FormatCurrency(spent), inline = true },
            { name = "Money Gained", value = Utils.FormatCurrency(gained), inline = true },
            { name = "Seeds Bought", value = seedsSummary, inline = false },
        },
        timestamp = DateTime.now():ToIsoDate(),
    }
end

local function IsValidDiscordWebhook(url)
    if type(url) ~= "string" then return false end
    -- normalize whitespace
    url = url:match("^%s*(.-)%s*$") or url
    -- Allow only Discord webhook endpoints (any subdomain of discord.com or legacy discordapp.com)
    if url:match("^https://[%w%%-%.]*discord%.com/api/webhooks/") then return true end
    if url:match("^https://[%w%%-%.]*discordapp%.com/api/webhooks/") then return true end
    return false
end

local function SendDiscordWebhook()
    if not Webhook.url or Webhook.url == "" then return false end
    if not IsValidDiscordWebhook(Webhook.url) then
        warn("Webhook blocked: invalid domain")
        Rayfield:Notify({
            Title = "Webhook Blocked",
            Content = "Invalid webhook domain. Use discord.com/discordapp.com",
            Duration = 4,
            Image = 4483362458,
        })
        return false
    end
    local payload = {
        content = nil,
        embeds = { BuildDiscordEmbed() },
    }
    local ok, res = pcall(function()
        return HttpService:RequestAsync({
            Url = Webhook.url,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload),
        })
    end)
    if not ok or not res or res.Success ~= true then
        if res and res.StatusCode then
            warn("Discord webhook failed: status ", res.StatusCode)
        end
        return false
    end
    return true
end

local function StartWebhookLoop()
    if Webhook.running then return end
    Webhook.running = true
    task.spawn(function()
        while Webhook.enabled do
            local sent = SendDiscordWebhook()
            if not sent then
                -- disable on failure to avoid spam and potential vulnerability
                Webhook.enabled = false
                if WebhookToggle then pcall(function() WebhookToggle:Set(false) end) end
                break
            end
            task.wait(math.max(10, tonumber(Webhook.interval) or 300))
        end
        Webhook.running = false
    end)
end

local WebhookToggle = SettingsTab:CreateToggle({
    Name = "Enable Discord Reports",
    CurrentValue = false,
    Flag = "EnableDiscordWebhook",
    Callback = function(value)
        Webhook.enabled = value
        if value then
            StartWebhookLoop()
        end
    end,
})

local WebhookTestButton = SettingsTab:CreateButton({
    Name = "Send Test Report",
    Callback = function()
        SendDiscordWebhook()
        Rayfield:Notify({
            Title = "Webhook",
            Content = "Test report sent (check your channel)",
            Duration = 3,
            Image = 4483362458,
        })
    end,
})

-- Configuration Save (Load is automatic via Rayfield settings)
local ConfigSection = SettingsTab:CreateSection("Config Management")

local SaveConfigButton = SettingsTab:CreateButton({
    Name = "Save Configuration",
    Callback = function()
        pcall(function() Rayfield:SaveConfiguration() end)
        Rayfield:Notify({
            Title = "Config",
            Content = "Configuration saved.",
            Duration = 2,
            Image = 4483362458,
        })
    end,
})

-- Ensure Rayfield restores saved flags/values and then sync webhook URL
pcall(function() Rayfield:LoadConfiguration() end)
LoadWebhookUrl()

print("Enhanced Auto Farm V2.0 loaded successfully!")
Rayfield:Notify({
	Title = "System Ready",
	Content = "Enhanced Auto Farm V2.0 initialized",
	Duration = 5,
	Image = 4483362458,
})
